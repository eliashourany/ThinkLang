import type * as AST from "../ast/nodes.js";
import { typeExprToJsonSchema, typeExprToTsType, type TypeDeclMap } from "./type-compiler.js";

export interface GeneratorOptions {
  replMode?: boolean;
}

export function generate(
  program: AST.ProgramNode,
  typeDecls: TypeDeclMap,
  options: GeneratorOptions = {},
  importedFunctions?: AST.FunctionDeclarationNode[]
): string {
  const gen = new CodeGenerator(typeDecls, options, importedFunctions);
  return gen.emitProgram(program);
}

class CodeGenerator {
  private lines: string[] = [];
  private indent = 0;
  private typeDecls: TypeDeclMap;
  private options: GeneratorOptions;
  private tempCounter = 0;
  private importedFunctions: AST.FunctionDeclarationNode[];
  private inPipelineStage = false;
  private inUncertainDecl = false;

  constructor(typeDecls: TypeDeclMap, options: GeneratorOptions, importedFunctions?: AST.FunctionDeclarationNode[]) {
    this.typeDecls = typeDecls;
    this.options = options;
    this.importedFunctions = importedFunctions ?? [];
  }

  private emit(line: string): void {
    const prefix = "  ".repeat(this.indent);
    this.lines.push(prefix + line);
  }

  private emitRaw(line: string): void {
    this.lines.push(line);
  }

  private freshTemp(): string {
    return `__tl_tmp${this.tempCounter++}`;
  }

  emitProgram(program: AST.ProgramNode): string {
    this.lines = [];

    // Preamble
    this.emitRaw(`// Generated by ThinkLang compiler`);
    this.emitRaw(`import * as __tl_runtime from "./src/runtime/index.js";`);
    this.emitRaw(``);

    if (this.options.replMode) {
      // In REPL mode, emit statements directly (they run in an async context)
      for (const stmt of program.body) {
        this.emitStatement(stmt);
      }
    } else {
      // Collect local type and function names for deduplication
      const localTypeNames = new Set<string>();
      const localFunctionNames = new Set<string>();
      for (const stmt of program.body) {
        if (stmt.type === "TypeDeclaration") localTypeNames.add(stmt.name);
        if (stmt.type === "FunctionDeclaration") localFunctionNames.add(stmt.name);
      }

      // Emit imported types (those not defined locally)
      for (const [name, decl] of this.typeDecls) {
        if (!localTypeNames.has(name)) {
          this.emitTypeDeclaration(decl);
          this.emitRaw(``);
        }
      }

      // Emit imported functions
      for (const fn of this.importedFunctions) {
        if (!localFunctionNames.has(fn.name)) {
          this.emitFunctionDeclaration(fn);
          this.emitRaw(``);
        }
      }

      // Emit type declarations and function declarations at top level
      const topLevel: AST.StatementNode[] = [];
      const mainBody: AST.StatementNode[] = [];

      for (const stmt of program.body) {
        if (stmt.type === "TypeDeclaration" || stmt.type === "FunctionDeclaration" || stmt.type === "ToolDeclaration") {
          topLevel.push(stmt);
        } else {
          mainBody.push(stmt);
        }
      }

      for (const stmt of topLevel) {
        this.emitStatement(stmt);
        this.emitRaw(``);
      }

      if (mainBody.length > 0) {
        this.emitRaw(`async function __tl_main() {`);
        this.indent++;
        for (const stmt of mainBody) {
          this.emitStatement(stmt);
        }
        this.indent--;
        this.emitRaw(`}`);
        this.emitRaw(``);
        this.emitRaw(`__tl_main().catch(console.error);`);
      }
    }

    return this.lines.join("\n");
  }

  private emitStatement(stmt: AST.StatementNode): void {
    switch (stmt.type) {
      case "TypeDeclaration":
        this.emitTypeDeclaration(stmt);
        break;
      case "ToolDeclaration":
        this.emitToolDeclaration(stmt);
        break;
      case "FunctionDeclaration":
        this.emitFunctionDeclaration(stmt);
        break;
      case "LetDeclaration":
        this.emitLetDeclaration(stmt);
        break;
      case "PrintStatement":
        this.emitPrintStatement(stmt);
        break;
      case "ExpressionStatement":
        this.emit(`${this.emitExpr(stmt.expression)};`);
        break;
      case "TryCatch":
        this.emitTryCatch(stmt);
        break;
      case "IfElse":
        this.emitIfElse(stmt);
        break;
      case "TestBlock":
        this.emitTestBlock(stmt);
        break;
      case "AssertStatement":
        this.emitAssertStatement(stmt);
        break;
    }
  }

  private emitTypeDeclaration(decl: AST.TypeDeclarationNode): void {
    // Type declarations are compile-time only; JSON schemas are inlined in think/infer/reason calls
    const fields = decl.fields.map(f => {
      const optional = f.typeExpr.type === "OptionalType" ? "?" : "";
      return `${f.name}${optional}: ${typeExprToTsType(f.typeExpr)}`;
    });
    this.emit(`// type ${decl.name} { ${fields.join("; ")} }`);
  }

  private emitToolDeclaration(decl: AST.ToolDeclarationNode): void {
    const params = decl.params.map(p => p.name).join(", ");
    const inputSchemaProps: string[] = [];
    const requiredFields: string[] = [];
    for (const p of decl.params) {
      const fieldSchema = JSON.stringify(typeExprToJsonSchema(p.typeExpr, this.typeDecls));
      inputSchemaProps.push(`${JSON.stringify(p.name)}: ${fieldSchema}`);
      requiredFields.push(JSON.stringify(p.name));
    }
    const inputSchema = `{ type: "object", properties: { ${inputSchemaProps.join(", ")} }, required: [${requiredFields.join(", ")}], additionalProperties: false }`;
    const description = decl.description ? JSON.stringify(decl.description) : JSON.stringify(`Tool: ${decl.name}`);
    this.emit(`const ${decl.name} = __tl_runtime.defineTool({`);
    this.indent++;
    this.emit(`name: ${JSON.stringify(decl.name)},`);
    this.emit(`description: ${description},`);
    this.emit(`input: ${inputSchema},`);
    this.emit(`execute: async ({ ${params} }) => {`);
    this.indent++;
    for (const stmt of decl.body) {
      this.emitStatement(stmt);
    }
    this.indent--;
    this.emit(`},`);
    this.indent--;
    this.emit(`});`);
  }

  private emitFunctionDeclaration(decl: AST.FunctionDeclarationNode): void {
    const params = decl.params
      .map(p => p.name)
      .join(", ");

    this.emit(`async function ${decl.name}(${params}) {`);
    this.indent++;
    for (const stmt of decl.body) {
      this.emitStatement(stmt);
    }
    this.indent--;
    this.emit(`}`);
  }

  private emitLetDeclaration(decl: AST.LetDeclarationNode): void {
    if (decl.isUncertain) this.inUncertainDecl = true;
    const expr = this.emitExpr(decl.value);
    this.inUncertainDecl = false;
    if (this.isAsyncExpr(decl.value)) {
      this.emit(`const ${decl.name} = await ${expr};`);
    } else {
      this.emit(`const ${decl.name} = ${expr};`);
    }
  }

  private emitPrintStatement(stmt: AST.PrintStatementNode): void {
    const expr = this.emitExpr(stmt.expression);
    if (this.isAsyncExpr(stmt.expression)) {
      const tmp = this.freshTemp();
      this.emit(`const ${tmp} = await ${expr};`);
      this.emit(`console.log(typeof ${tmp} === "object" ? JSON.stringify(${tmp}, null, 2) : ${tmp});`);
    } else {
      this.emit(`console.log(typeof (${expr}) === "object" ? JSON.stringify(${expr}, null, 2) : ${expr});`);
    }
  }

  private emitTryCatch(node: AST.TryCatchNode): void {
    this.emit(`try {`);
    this.indent++;
    for (const stmt of node.tryBody) {
      this.emitStatement(stmt);
    }
    this.indent--;

    if (node.catchClauses.length === 1) {
      const clause = node.catchClauses[0];
      this.emit(`} catch (${clause.binding}) {`);
      this.indent++;
      this.emit(`if (!(${clause.binding} instanceof __tl_runtime.${clause.errorType})) throw ${clause.binding};`);
      for (const stmt of clause.body) {
        this.emitStatement(stmt);
      }
      this.indent--;
      this.emit(`}`);
    } else {
      this.emit(`} catch (__tl_err) {`);
      this.indent++;
      for (let i = 0; i < node.catchClauses.length; i++) {
        const clause = node.catchClauses[i];
        const keyword = i === 0 ? "if" : "else if";
        this.emit(`${keyword} (__tl_err instanceof __tl_runtime.${clause.errorType}) {`);
        this.indent++;
        this.emit(`const ${clause.binding} = __tl_err;`);
        for (const stmt of clause.body) {
          this.emitStatement(stmt);
        }
        this.indent--;
        this.emit(`}`);
      }
      this.emit(`else { throw __tl_err; }`);
      this.indent--;
      this.emit(`}`);
    }
  }

  private emitIfElse(node: AST.IfElseNode): void {
    const cond = this.emitExpr(node.condition);
    this.emit(`if (${cond}) {`);
    this.indent++;
    for (const stmt of node.thenBody) {
      this.emitStatement(stmt);
    }
    this.indent--;
    if (node.elseBody) {
      this.emit(`} else {`);
      this.indent++;
      for (const stmt of node.elseBody) {
        this.emitStatement(stmt);
      }
      this.indent--;
    }
    this.emit(`}`);
  }

  private emitTestBlock(stmt: AST.TestBlockNode): void {
    const desc = JSON.stringify(stmt.description);
    this.emit(`// test ${desc}`);
    this.emit(`await (async () => {`);
    this.indent++;
    this.emit(`const __tl_test_desc = ${desc};`);
    this.emit(`try {`);
    this.indent++;
    for (const bodyStmt of stmt.body) {
      this.emitStatement(bodyStmt);
    }
    this.emit(`console.log("  PASS: " + __tl_test_desc);`);
    this.indent--;
    this.emit(`} catch (__tl_test_err) {`);
    this.indent++;
    this.emit(`console.error("  FAIL: " + __tl_test_desc + " — " + __tl_test_err.message);`);
    this.indent--;
    this.emit(`}`);
    this.indent--;
    this.emit(`})();`);
  }

  private emitAssertStatement(stmt: AST.AssertStatementNode): void {
    if (stmt.kind === "value" && stmt.expression) {
      const expr = this.emitExpr(stmt.expression);
      if (this.isAsyncExpr(stmt.expression)) {
        const tmp = this.freshTemp();
        this.emit(`const ${tmp} = await ${expr};`);
        this.emit(`if (!${tmp}) throw new Error("Assertion failed: " + ${JSON.stringify(this.exprToSource(stmt.expression))});`);
      } else {
        this.emit(`if (!(${expr})) throw new Error("Assertion failed: " + ${JSON.stringify(this.exprToSource(stmt.expression))});`);
      }
    } else if (stmt.kind === "semantic" && stmt.subject && stmt.criteria) {
      const subject = this.emitExpr(stmt.subject);
      const criteria = this.emitExpr(stmt.criteria);
      const tmp = this.freshTemp();
      this.emit(`const ${tmp} = await __tl_runtime.think({ jsonSchema: { type: "object", properties: { passes: { type: "boolean" }, explanation: { type: "string" } }, required: ["passes", "explanation"], additionalProperties: false }, prompt: "Does this value satisfy the criteria? Value: " + JSON.stringify(${subject}) + " Criteria: " + ${criteria}, schemaName: "semantic_assert" });`);
      this.emit(`if (!${tmp}.passes) throw new Error("Semantic assertion failed: " + ${tmp}.explanation);`);
    }
  }

  private exprToSource(expr: AST.ExpressionNode): string {
    // Simple source reconstruction for error messages
    switch (expr.type) {
      case "BinaryExpression":
        return `${this.exprToSource(expr.left)} ${expr.operator} ${this.exprToSource(expr.right)}`;
      case "IdentifierExpression":
        return expr.name;
      case "StringLiteral":
        return `"${expr.value}"`;
      case "NumberLiteral":
        return String(expr.value);
      case "BooleanLiteral":
        return String(expr.value);
      default:
        return "<expression>";
    }
  }

  private emitExpr(expr: AST.ExpressionNode): string {
    switch (expr.type) {
      case "ThinkExpression":
        return this.emitThinkExpr(expr);
      case "InferExpression":
        return this.emitInferExpr(expr);
      case "ReasonBlock":
        return this.emitReasonBlock(expr);
      case "AgentExpression":
        return this.emitAgentExpr(expr);
      case "PipelineExpression":
        return this.emitPipeline(expr);
      case "MatchExpression":
        return this.emitMatchExpr(expr);
      case "FunctionCallExpression":
        return this.emitFunctionCall(expr);
      case "MemberExpression":
        return this.emitMemberExpr(expr);
      case "IdentifierExpression":
        return expr.name;
      case "StringLiteral":
        return JSON.stringify(expr.value);
      case "NumberLiteral":
        return String(expr.value);
      case "BooleanLiteral":
        return String(expr.value);
      case "NullLiteral":
        return "null";
      case "ArrayLiteral":
        return `[${expr.elements.map(e => this.emitExpr(e)).join(", ")}]`;
      case "ObjectLiteral":
        return this.emitObjectLiteral(expr);
      case "BinaryExpression":
        return `(${this.emitExpr(expr.left)} ${expr.operator} ${this.emitExpr(expr.right)})`;
      case "UnaryExpression":
        return `(${expr.operator}${this.emitExpr(expr.operand)})`;
      case "RangeExpression":
        return `{ start: ${this.emitExpr(expr.start)}, end: ${this.emitExpr(expr.end)} }`;
      default:
        return `/* unknown expression: ${(expr as any).type} */`;
    }
  }

  private emitThinkExpr(expr: AST.ThinkExpressionNode): string {
    const schema = JSON.stringify(typeExprToJsonSchema(expr.typeArgument, this.typeDecls));
    const prompt = this.emitExpr(expr.prompt);
    const parts = [`jsonSchema: ${schema}`, `prompt: ${prompt}`];

    parts.push(`context: ${this.emitContextArg(expr.withContext)}`);

    if (expr.withoutContext) {
      parts.push(`withoutKeys: ${this.emitWithoutKeys(expr.withoutContext)}`);
    }

    if (expr.guard) {
      parts.push(`guards: ${this.emitGuardRules(expr.guard)}`);
    }

    if (expr.onFail) {
      parts.push(`retryCount: ${expr.onFail.retryCount}`);
      if (expr.onFail.fallback) {
        parts.push(`fallback: () => (${this.emitExpr(expr.onFail.fallback)})`);
      }
    }

    if (this.inUncertainDecl) {
      parts.push(`uncertain: true`);
    }

    return `__tl_runtime.think({ ${parts.join(", ")} })`;
  }

  private emitInferExpr(expr: AST.InferExpressionNode): string {
    const schema = JSON.stringify(typeExprToJsonSchema(expr.typeArgument, this.typeDecls));
    const value = this.emitExpr(expr.value);
    const parts = [`jsonSchema: ${schema}`, `value: ${value}`];

    if (expr.hint) {
      parts.push(`hint: ${this.emitExpr(expr.hint)}`);
    }

    parts.push(`context: ${this.emitContextArg(expr.withContext)}`);

    if (expr.withoutContext) {
      parts.push(`withoutKeys: ${this.emitWithoutKeys(expr.withoutContext)}`);
    }

    if (expr.guard) {
      parts.push(`guards: ${this.emitGuardRules(expr.guard)}`);
    }

    if (expr.onFail) {
      parts.push(`retryCount: ${expr.onFail.retryCount}`);
      if (expr.onFail.fallback) {
        parts.push(`fallback: () => (${this.emitExpr(expr.onFail.fallback)})`);
      }
    }

    if (this.inUncertainDecl) {
      parts.push(`uncertain: true`);
    }

    return `__tl_runtime.infer({ ${parts.join(", ")} })`;
  }

  private emitReasonBlock(expr: AST.ReasonBlockNode): string {
    const schema = JSON.stringify(typeExprToJsonSchema(expr.typeArgument, this.typeDecls));
    const goal = JSON.stringify(expr.goal);
    const steps = JSON.stringify(expr.steps.map(s => ({ number: s.number, description: s.description })));
    const parts = [
      `jsonSchema: ${schema}`,
      `goal: ${goal}`,
      `steps: ${steps}`,
    ];

    parts.push(`context: ${this.emitContextArg(expr.withContext)}`);

    if (expr.withoutContext) {
      parts.push(`withoutKeys: ${this.emitWithoutKeys(expr.withoutContext)}`);
    }

    if (expr.guard) {
      parts.push(`guards: ${this.emitGuardRules(expr.guard)}`);
    }

    if (expr.onFail) {
      parts.push(`retryCount: ${expr.onFail.retryCount}`);
      if (expr.onFail.fallback) {
        parts.push(`fallback: () => (${this.emitExpr(expr.onFail.fallback)})`);
      }
    }

    return `__tl_runtime.reason({ ${parts.join(", ")} })`;
  }

  private emitAgentExpr(expr: AST.AgentExpressionNode): string {
    const schema = JSON.stringify(typeExprToJsonSchema(expr.typeArgument, this.typeDecls));
    const prompt = this.emitExpr(expr.prompt);
    const parts = [`jsonSchema: ${schema}`, `prompt: ${prompt}`];

    // Tool references
    if (expr.tools.length > 0) {
      parts.push(`tools: [${expr.tools.join(", ")}]`);
    } else {
      parts.push(`tools: []`);
    }

    if (expr.withContext) {
      parts.push(`context: ${this.emitContextArg(expr.withContext)}`);
    }

    if (expr.maxTurns) {
      parts.push(`maxTurns: ${expr.maxTurns}`);
    }

    if (expr.guard) {
      parts.push(`guards: ${this.emitGuardRules(expr.guard)}`);
    }

    if (expr.onFail) {
      parts.push(`retryCount: ${expr.onFail.retryCount}`);
      if (expr.onFail.fallback) {
        parts.push(`fallback: () => (${this.emitExpr(expr.onFail.fallback)})`);
      }
    }

    return `__tl_runtime.agent({ ${parts.join(", ")} })`;
  }

  private emitPipeline(expr: AST.PipelineExpressionNode): string {
    // Pipeline: a |> b |> c → sequential temp variables
    // Left result feeds into right as context
    const temps: string[] = [];
    let prev = "";

    for (let i = 0; i < expr.stages.length; i++) {
      const stage = expr.stages[i];
      const tmp = this.freshTemp();
      temps.push(tmp);

      if (i === 0) {
        // First stage: evaluate directly
        prev = tmp;
      }
    }

    // Build as an IIFE
    // Compile first stage normally, subsequent stages with pipeline context
    const firstExpr = this.emitExpr(expr.stages[0]);
    if (expr.stages.length === 1) return firstExpr;

    this.inPipelineStage = true;
    const restExprs = expr.stages.slice(1).map(s => this.emitExpr(s));
    this.inPipelineStage = false;

    let code = `(async () => { `;
    code += `let ${temps[0]} = await ${firstExpr}; `;
    for (let i = 0; i < restExprs.length; i++) {
      code += `let __tl_pipe_input = ${temps[i]}; `;
      code += `let ${temps[i + 1]} = await ${restExprs[i]}; `;
    }
    code += `return ${temps[temps.length - 1]}; `;
    code += `})()`;

    return code;
  }

  private emitMatchExpr(expr: AST.MatchExpressionNode): string {
    const subject = this.emitExpr(expr.subject);
    const matchVar = this.freshTemp();
    const resultVar = this.freshTemp();

    let code = `((${matchVar}) => { let ${resultVar}; `;

    for (let i = 0; i < expr.arms.length; i++) {
      const arm = expr.arms[i];
      const keyword = i === 0 ? "if" : "else if";

      if (arm.pattern.type === "WildcardPattern") {
        if (i === 0) {
          code += `${resultVar} = ${this.emitExpr(arm.body)}; `;
        } else {
          code += `else { ${resultVar} = ${this.emitExpr(arm.body)}; } `;
        }
      } else if (arm.pattern.type === "ObjectPattern") {
        const conditions = arm.pattern.fields.map(f => {
          if (f.constraint.type === "ComparisonConstraint") {
            return `${matchVar}.${f.name} ${f.constraint.operator} ${this.emitExpr(f.constraint.value)}`;
          } else {
            return `${matchVar}.${f.name} === ${this.emitExpr(f.constraint.value)}`;
          }
        });
        code += `${keyword} (${conditions.join(" && ")}) { ${resultVar} = ${this.emitExpr(arm.body)}; } `;
      } else if (arm.pattern.type === "LiteralPattern") {
        code += `${keyword} (${matchVar} === ${this.emitExpr(arm.pattern.value)}) { ${resultVar} = ${this.emitExpr(arm.body)}; } `;
      }
    }

    code += `return ${resultVar}; })(${subject})`;
    return code;
  }

  private emitFunctionCall(expr: AST.FunctionCallExpressionNode): string {
    const callee = this.emitExpr(expr.callee);
    const args = expr.args.map(a => this.emitExpr(a)).join(", ");
    return `${callee}(${args})`;
  }

  private emitMemberExpr(expr: AST.MemberExpressionNode): string {
    return `${this.emitExpr(expr.object)}.${expr.property}`;
  }

  private emitObjectLiteral(expr: AST.ObjectLiteralNode): string {
    const props = expr.properties.map(p =>
      `${p.key}: ${this.emitExpr(p.value)}`
    ).join(", ");
    return `{ ${props} }`;
  }

  private emitContextArg(ctx: AST.ContextExpressionNode | null | undefined): string {
    const pipeEntry = this.inPipelineStage ? '"previous_result": __tl_pipe_input' : "";

    if (!ctx) {
      return pipeEntry ? `{ ${pipeEntry} }` : "{}";
    }

    if (ctx.type === "ContextBlock") {
      const entries = ctx.entries.map(e => {
        if (e.type === "IdentifierExpression") {
          return e.name;
        } else if (e.type === "MemberExpression") {
          // foo.bar → "foo.bar": foo.bar
          const key = this.getMemberPath(e);
          const val = this.emitExpr(e);
          return `"${key}": ${val}`;
        }
        return "";
      });
      if (pipeEntry) entries.unshift(pipeEntry);
      return `{ ${entries.join(", ")} }`;
    }

    if (ctx.type === "IdentifierExpression") {
      const entries = [`"${ctx.name}": ${ctx.name}`];
      if (pipeEntry) entries.unshift(pipeEntry);
      return `{ ${entries.join(", ")} }`;
    }

    if (ctx.type === "MemberExpression") {
      const key = this.getMemberPath(ctx);
      const val = this.emitExpr(ctx);
      const entries = [`"${key}": ${val}`];
      if (pipeEntry) entries.unshift(pipeEntry);
      return `{ ${entries.join(", ")} }`;
    }

    return pipeEntry ? `{ ${pipeEntry} }` : "{}";
  }

  private getMemberPath(expr: AST.MemberExpressionNode): string {
    if (expr.object.type === "IdentifierExpression") {
      return `${expr.object.name}.${expr.property}`;
    } else if (expr.object.type === "MemberExpression") {
      return `${this.getMemberPath(expr.object)}.${expr.property}`;
    }
    return expr.property;
  }

  private emitWithoutKeys(ctx: AST.ContextExpressionNode): string {
    if (ctx.type === "ContextBlock") {
      const keys = ctx.entries.map(e => {
        if (e.type === "IdentifierExpression") return JSON.stringify(e.name);
        if (e.type === "MemberExpression") return JSON.stringify(this.getMemberPath(e));
        return '""';
      });
      return `[${keys.join(", ")}]`;
    }
    if (ctx.type === "IdentifierExpression") {
      return `[${JSON.stringify(ctx.name)}]`;
    }
    if (ctx.type === "MemberExpression") {
      return `[${JSON.stringify(this.getMemberPath(ctx))}]`;
    }
    return "[]";
  }

  private emitGuardRules(guard: AST.GuardClauseNode): string {
    const rules = guard.rules.map(r => {
      const parts = [`name: ${JSON.stringify(r.name)}`];
      parts.push(`constraint: ${this.emitExpr(r.constraint)}`);
      if (r.rangeEnd) {
        parts.push(`rangeEnd: ${this.emitExpr(r.rangeEnd)}`);
      }
      return `{ ${parts.join(", ")} }`;
    });
    return `[${rules.join(", ")}]`;
  }

  private isAsyncExpr(expr: AST.ExpressionNode): boolean {
    switch (expr.type) {
      case "ThinkExpression":
      case "InferExpression":
      case "ReasonBlock":
      case "AgentExpression":
      case "PipelineExpression":
        return true;
      case "FunctionCallExpression":
        return true; // Might be async
      default:
        return false;
    }
  }
}
